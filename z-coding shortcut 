const int buzzerPin = 13;
const int buttonPin = 6;
const int potPin = A0;

int buttonState = 0;
int lastButtonState = 0;
bool isPlaying = false;

unsigned long lastDebounceTime = 0;
unsigned long debounceDelay = 50;

int melody[] = {262, 294, 330, 349, 392, 440, 494, 523}; // C4 to C5 notes
int noteDurations[] = {4, 4, 4, 4, 4, 4, 4, 4}; // All notes as quarter notes

void setup() {
  pinMode(buzzerPin, OUTPUT);
  pinMode(buttonPin, INPUT_PULLUP); // Button with internal pull-up resistor
  Serial.begin(9600);
}

void loop() {
  int potValue = analogRead(potPin); // Read potentiometer value
  int pitchOffset = map(potValue, 0, 1023, -100, 100); // Map pot value to pitch offset

  int reading = digitalRead(buttonPin); // Read button state
  
  if (reading != lastButtonState) {
    lastDebounceTime = millis(); // Reset the debounce timer
  }

  if ((millis() - lastDebounceTime) > debounceDelay) {
    if (reading == LOW && buttonState == HIGH) {
      isPlaying = !isPlaying; // Toggle melody play state
    }
    buttonState = reading;
  }

  lastButtonState = reading;

  if (isPlaying) {
    playMelody(pitchOffset); // Play melody with adjusted pitch
  } else {
    noTone(buzzerPin); // Stop the melody
  }
}

void playMelody(int pitchOffset) {
  for (int thisNote = 0; thisNote < 8; thisNote++) {
    if (!isPlaying) break; // Check if melody should stop
    
    int noteDuration = 1000 / noteDurations[thisNote];
    int adjustedFrequency = melody[thisNote] + pitchOffset; // Adjust frequency
    
    tone(buzzerPin, adjustedFrequency, noteDuration);
    delay(noteDuration * 1.3);
  }
}



//////

const int buzzerPin = 13; // Pin 13 for buzzer
const int buttonPin = 6;  // Pin 6 for button
const int potPin = A0;    // Analog pin A0 for potentiometer

int buttonState = 0;
int lastButtonState = 0;
bool isPlaying = false;

unsigned long lastDebounceTime = 0;
unsigned long debounceDelay = 50;

int melody[] = {262, 294, 330, 349, 392, 440, 494, 523}; // C4 to C5 notes
int noteDurations[] = {4, 4, 4, 4, 4, 4, 4, 4}; // All notes as quarter notes

void setup() {
  // Configure buzzer pin (Pin 13) as output by setting bit 5 of DDRB
  DDRB |= (1 << DDB5);

  // Configure button pin (Pin 6) as input by clearing bit 6 of DDRD
  DDRD &= ~(1 << DDD6);

  // Enable internal pull-up resistor for button pin (Pin 6) by setting bit 6 of PORTD
  PORTD |= (1 << PORTD6);

  // Set up serial communication for debugging (optional)
  Serial.begin(9600);
}

void loop() {
  int potValue = analogRead(potPin); // Read potentiometer value
  int pitchOffset = map(potValue, 0, 1023, -100, 100); // Map pot value to pitch offset

  // Read the button state directly from PIND (bit 6 corresponds to Pin 6)
  int reading = (PIND & (1 << PIND6)) ? HIGH : LOW;
  
  if (reading != lastButtonState) {
    lastDebounceTime = millis(); // Reset the debounce timer
  }

  if ((millis() - lastDebounceTime) > debounceDelay) {
    if (reading == LOW && buttonState == HIGH) {
      isPlaying = !isPlaying; // Toggle melody play state
    }
    buttonState = reading;
  }

  lastButtonState = reading;

  if (isPlaying) {
    playMelody(pitchOffset); // Play melody with adjusted pitch
  } else {
    // Stop the melody by turning off the buzzer
    noTone(buzzerPin);
  }
}

void playMelody(int pitchOffset) {
  for (int thisNote = 0; thisNote < 8; thisNote++) {
    if (!isPlaying) break; // Check if melody should stop

    int noteDuration = 1000 / noteDurations[thisNote];
    int adjustedFrequency = melody[thisNote] + pitchOffset; // Adjust frequency

    // Play the note using tone (no need for direct register manipulation for tone)
    tone(buzzerPin, adjustedFrequency, noteDuration);
    
    delay(noteDuration * 1.3);
  }
}