Note title: C library to learn
Note author: Marziel60D

1. Standard Input/Output Library (stdio.h)
Functions: printf(), scanf(), fprintf(), fscanf(), fgets(), fputs(), fopen(), fclose()
Purpose: Provides functions for input and output operations, such as reading/writing from/to the console and files.

2. String Manipulation Library (string.h)
Functions: strlen(), strcpy(), strncpy(), strcat(), strcmp(), strstr(), memcpy()
Purpose: Contains functions for manipulating C-style strings (character arrays) and memory blocks.

3. Mathematics Library (math.h)
Functions: sqrt(), pow(), sin(), cos(), tan(), log(), abs(), ceil(), floor()
Purpose: Provides mathematical functions like power, trigonometric, logarithmic, and exponential functions.

4. Dynamic Memory Allocation Library (stdlib.h)
Functions: malloc(), calloc(), realloc(), free(), exit(), system(), atoi(), rand(), srand()
Purpose: Includes functions for dynamic memory management, conversions, and process control.

5. Time Library (time.h)
Functions: time(), difftime(), clock(), asctime(), ctime(), gmtime(), localtime(), strftime()
Purpose: Used for handling date and time operations, including getting the current time and manipulating time structures.

6. Character Classification Library (ctype.h)
Functions: isalpha(), isdigit(), isalnum(), isupper(), islower(), isspace(), toupper(), tolower()
Purpose: Provides functions for classifying and converting characters (e.g., checking if a character is a letter or a digit).

7. Error Handling Library (errno.h)
Macros: errno, EDOM, ERANGE
Purpose: Defines macros for reporting and handling errors, providing a mechanism to check for error conditions in library functions.

8. Signal Handling Library (signal.h)
Functions: signal(), raise(), kill(), alarm(), pause()
Purpose: Used to handle various signals (e.g., interrupt signals) and signal-related actions in a C program.

9. Input/Output Control Library (fcntl.h)
Functions: open(), creat(), fcntl()
Purpose: Provides functions for file handling at a lower level than the stdio.h library.

10. File Control Operations Library (unistd.h)
Functions: read(), write(), close(), lseek(), getpid(), fork(), exec()
Purpose: Contains functions for interacting with the operating system, particularly in Unix-like systems (e.g., file descriptors and process control).

11. Assert Library (assert.h)
Functions: assert()
Purpose: Allows for runtime diagnostics through the use of assertions, which help in debugging.

12. Limits Library (limits.h)
Macros: INT_MAX, INT_MIN, CHAR_MAX, LONG_MAX, LONG_MIN
Purpose: Defines constants for the limits of basic data types (e.g., maximum and minimum values of int, char, long).

13. Float Library (float.h)
Macros: FLT_MAX, FLT_MIN, DBL_MAX, DBL_MIN
Purpose: Defines macros for limits related to floating-point types (e.g., precision, maximum, and minimum values).

14. Locale Library (locale.h)
Functions: setlocale(), localeconv()
Purpose: Provides functions for setting and querying the locale, which affects things like date and time formats, currency, and number formatting.

15. Complex Numbers Library (complex.h)
Functions: cabs(), creal(), cimag(), cexp(), clog()
Purpose: Provides support for operations on complex numbers.

16. Set Jump Library (setjmp.h)
Functions: setjmp(), longjmp()
Purpose: Provides non-local jumps, allowing for the saving and restoring of execution state, useful for error handling and recovery.

17. Standard Integer Types Library (stdint.h)
Macros/Types: int8_t, int16_t, int32_t, int64_t, uint8_t, UINT32_MAX, INTPTR_MAX
Purpose: Defines exact-width integer types, as well as limits for integer types.

18. Type Definitions Library (stddef.h)
Macros/Types: size_t, ptrdiff_t, NULL, offsetof()
Purpose: Contains type definitions for several standard types like size_t and ptrdiff_t.





#include <EEPROM.h>       // Include EEPROM library for storing values

const int button1Pin = 6; // Play/Stop button connected to digital pin 6
const int button2Pin = 5; // Record button connected to digital pin 5
const int buzzerPin = 13; // Speaker connected to digital pin 13
const int potPin = A0;    // Potentiometer connected to analog pin A0

int melody[] = { NOTE_C4, NOTE_G3, NOTE_G3, NOTE_A3, NOTE_G3, 0, NOTE_B3, NOTE_C4 }; // Melody notes
int noteDurations[] = {4, 8, 8, 4, 4, 4, 4, 4};                                    // Note durations
int numNotes = sizeof(melody) / sizeof(melody[0];                                  // Number of notes

bool isPlaying = false;   // Tracks whether the melody is playing or not
bool recording = false;   // Tracks if pitch is being recorded
int lastButton1State = LOW; // Last button 1 state for debouncing
int lastButton2State = LOW; // Last button 2 state for debouncing
int currentNoteIndex = 0;   // Track the current note when stopping/starting

int eepromAddress = 0;    // EEPROM memory address for saving pitch
int savedPitchAdjust = 0; // Pitch adjustment saved in EEPROM
int pitchAdjust = 0;      // Current pitch adjustment from potentiometer

void setup() {
  Serial.begin(9600);                                         // Start serial communication
  savedPitchAdjust = EEPROM.read(eepromAddress);              // Retrieve the saved pitch from EEPROM
  if (savedPitchAdjust > 100 || savedPitchAdjust < -100) {    // Check if the value is valid
    savedPitchAdjust = 0;                                     // Initialize to 0 if out of expected range
  }
}

void loop() {
  int potValue = analogRead(potPin);                          // Read potentiometer value
  pitchAdjust = map(potValue, 0, 1023, -100, 100);            // Map value to pitch adjustment range

  int button1State = (PIND & (1 << button1Pin)) ? HIGH : LOW; // Read button 1 state (using port manipulation)
  int button2State = (PIND & (1 << button2Pin)) ? HIGH : LOW; // Read button 2 state

  if (button1State == HIGH && lastButton1State == LOW) {      // Toggle play/stop
    isPlaying = !isPlaying;                                   // Toggle between play and stop
    delay(50);                                                // Debouncing delay
  }
  lastButton1State = button1State;                            // Update last button state

  if (button2State == HIGH && lastButton2State == LOW) {      // Record pitch to EEPROM
    recording = true;                                         // Mark pitch as being recorded
    savedPitchAdjust = pitchAdjust;                           // Save the current pitch adjustment
    EEPROM.write(eepromAddress, savedPitchAdjust);            // Write the value to EEPROM
    delay(50);                                                // Debouncing delay
  }
  lastButton2State = button2State;                            // Update last button state

  if (button1State == HIGH && button2State == HIGH) {         // Simultaneous button press
    isPlaying = false;                                        // Stop melody
    currentNoteIndex = 0;                                     // Reset playback position
  }

  if (isPlaying) {                                            // Melody playback logic
    int adjustedFrequency = melody[currentNoteIndex] + savedPitchAdjust + pitchAdjust; // Adjust pitch
    int noteDuration = 1000 / noteDurations[currentNoteIndex]; // Get note duration
    tone(buzzerPin, adjustedFrequency, noteDuration);         // Play the note with adjusted pitch

    unsigned long noteStartTime = millis();                   // Start the note timer
    while (millis() - noteStartTime < noteDuration * 1.30) {  // Play the note for the set duration
      button1State = (PIND & (1 << button1Pin)) ? HIGH : LOW; // Check button 1 state again during note
      if (button1State == HIGH && lastButton1State == LOW) {  // Stop melody if button is pressed
        isPlaying = false;                                    // Stop melody
        noTone(buzzerPin);                                    // Stop the buzzer
        delay(50);                                            // Debouncing delay
        break;                                                // Exit the loop early
      }
      lastButton1State = button1State;                        // Update last button state
    }

    currentNoteIndex++;                                       // Move to next note
    if (currentNoteIndex >= numNotes) {                       // Check if all notes are played
      currentNoteIndex = 0;                                   // Loop back to the start of the melody
    }
  } else {
    noTone(buzzerPin);                                        // Stop the buzzer when the melody is stopped
  }
}