https://wokwi.com/projects/409728257464481793



#include <EEPROM.h>
#define NOTE_C4  262
#define NOTE_G3  196
#define NOTE_A3  220
#define NOTE_B3  247

// Pin definitions
const int buttonPin1 = 6;   // Button 1 for toggling play/stop
const int buttonPin2 = 5;   // Button 2 for recording pitch
const int buzzerPin = 13;   // Speaker
const int potPin = A0;      // Potentiometer

// Melody settings (same as the original melody in "Tone Melody" example)
int melody[] = { NOTE_C4, NOTE_G3, NOTE_G3, NOTE_A3, NOTE_G3, 0, NOTE_B3, NOTE_C4 };
int noteDurations[] = {4, 8, 8, 4, 4, 4, 4, 4};
int numNotes = sizeof(melody) / sizeof(melody[0]);

// Playback control variables
bool isPlaying = true;
int lastButton1State = LOW;
int lastButton2State = LOW;
int melodyPosition = 0;  // Keep track of where the melody stopped
int storedPitchAdjust = 0; // Value stored in EEPROM
int pitchAdjust = 0;  // Adjusted pitch based on potentiometer
int potValue;
int button1State;
int button2State;
int adjustedFrequency;
int noteDuration;
int savedPitch;

void setup() {
  pinMode(buttonPin1, INPUT);
  pinMode(buttonPin2, INPUT);
  pinMode(buzzerPin, OUTPUT);
  Serial.begin(9600);

  // Retrieve stored pitch adjust value from EEPROM (Address 0)
  storedPitchAdjust = EEPROM.read(0);
  Serial.print("Stored pitch from EEPROM: ");
  Serial.println(storedPitchAdjust);
}

void loop() {
  // Read potentiometer value and map it to pitch adjustment range (-100Hz to +100Hz)
  potValue = analogRead(potPin);
  pitchAdjust = map(potValue, 0, 1004, -100, 100);

  // Add stored pitch adjust to the current value from the potentiometer
  int totalPitchAdjust = storedPitchAdjust + pitchAdjust;
  Serial.print("Total pitch adjust (stored + current): ");
  Serial.println(totalPitchAdjust);

  // Read button states
  button1State = digitalRead(buttonPin1);
  button2State = digitalRead(buttonPin2);

  // Handle button 1 for toggling play/stop
  if (button1State == HIGH && lastButton1State == LOW) {
    isPlaying = !isPlaying;  // Toggle between play and stop
    delay(50);               // Debouncing delay
  }
  lastButton1State = button1State;  // Update the last state of button 1

  // Handle button 2 for recording pitch (can record even when melody is playing or stopped)
  if (button2State == HIGH && lastButton2State == LOW) {
    EEPROM.write(0, totalPitchAdjust);  // Store the total pitch adjustment value in EEPROM
    storedPitchAdjust = totalPitchAdjust;  // Update the stored pitch
    Serial.println("Pitch saved to EEPROM.");
    delay(50);  // Debouncing delay
  }
  lastButton2State = button2State;  // Update the last state of button 2

  // Handle simultaneous button press (both button 1 and 2)
  if (button1State == HIGH && button2State == HIGH) {
    isPlaying = false;  // Stop melody playback
    melodyPosition = 0;  // Reset melody position to start
  }

  // Play melody if it's toggled to play mode
  if (isPlaying) {
    int currentNote = melody[melodyPosition];

    // Apply stored and current pitch adjustment only if the note is not zero
    if (currentNote != 0) {
      adjustedFrequency = currentNote + totalPitchAdjust;
      // Calculate note duration
      noteDuration = 1000 / noteDurations[melodyPosition];
      tone(buzzerPin, adjustedFrequency, noteDuration);
      Serial.print("Playing note: ");
      Serial.println(adjustedFrequency);
    } else {
      Serial.println("Resting (0 note).");
      noTone(buzzerPin);  // Mute for rest (0 note)
    }

    // Wait for the note to finish playing
    delay(noteDuration * 1.30);
    noTone(buzzerPin);  // Stop the tone after playing

    // Move to the next note
    melodyPosition++;
    if (melodyPosition >= numNotes) {
      melodyPosition = 0;  // Loop back to the start of the melody
    }
  } else {

    noTone(buzzerPin);  // Ensure buzzer is off when stopped
  }
}

////////////////
https://wokwi.com/projects/409472516168491009

#include <avr/wdt.h>
#include <LiquidCrystal.h>

// LCD pin configuration (RS, EN, D4, D5, D6, D7)
LiquidCrystal lcd(12, 11, 10, 9, 8, 7);

// Push button pin definitions
const int btnCountUp = 5;   // Push Button 1 for Count Up (PD5)
const int btnCountDown = 4; // Push Button 2 for Count Down (PD4)
const int btnStopReset = 3; // Push Button 3 for Stop/Reset (PD3)
const int btnWaitIncrease = 2; // Push Button 4 for Wait Time Increase (PD2)

// Stopwatch states
enum State {
  STOP,
  COUNT_UP,
  COUNT_DOWN
};

volatile State currentState = STOP;

volatile int seconds = 0;
volatile int tenths = 0;
volatile bool counting = false;
volatile int waitTime = 0; // Wait time in ms, increased by button 4

// Timer1 interrupt service routine (ISR) for 10ms intervals
ISR(TIMER1_COMPA_vect) {
  if (currentState == COUNT_UP) {
    tenths += 1;
    if (tenths >= 10) {
      tenths = 0;
      seconds += 1;
    }
    if (seconds >= 20 && tenths == 0) {
      currentState = STOP;
      counting = false;
    }
  } else if (currentState == COUNT_DOWN) {
    if (tenths == 0 && seconds > 0) {
      tenths = 9;
      seconds -= 1;
    } else if (tenths > 0) {
      tenths -= 1;
    }
    if (seconds == 0 && tenths == 0) {
      currentState = STOP;
      counting = false;
    }
  }
}

void setup() {
  lcd.begin(16, 2); // 16x2 LCD initialization
  lcd.clear();

  // Button input configuration
  DDRD &= ~(1 << btnCountUp);
  DDRD &= ~(1 << btnCountDown);
  DDRD &= ~(1 << btnStopReset);
  DDRD &= ~(1 << btnWaitIncrease);

  PORTD |= (1 << btnCountUp);
  PORTD |= (1 << btnCountDown);
  PORTD |= (1 << btnStopReset);
  PORTD |= (1 << btnWaitIncrease);

  // Timer1 setup for 10ms interrupts
  noInterrupts();
  TCCR1A = 0;
  TCCR1B = 0;
  TCNT1 = 0;
  OCR1A = 1562; // Compare match value for 10ms
  TCCR1B |= (1 << WGM12);
  TCCR1B |= (1 << CS12) | (1 << CS10);
  TIMSK1 |= (1 << OCIE1A);
  interrupts();

  // Watchdog Timer setup with 250ms timeout
  wdt_enable(WDTO_250MS);
}

void loop() {
  if (bit_is_clear(PIND, btnCountUp)) {  // Button 1 (Count Up)
    if (!counting && currentState == STOP) {
      currentState = COUNT_UP;
      counting = true;
    }
    delay(200); // Debouncing
  }

  if (bit_is_clear(PIND, btnCountDown)) { // Button 2 (Count Down)
    if (!counting && currentState == STOP) {
      currentState = COUNT_DOWN;
      counting = true;
    }
    delay(200); // Debouncing
  }

  if (bit_is_clear(PIND, btnStopReset)) { // Button 3 (Stop/Reset)
    if (counting) {
      counting = false;
      currentState = STOP;
    } else {
      seconds = 0;
      tenths = 0;
    }
    delay(200); // Debouncing
  }

  if (bit_is_clear(PIND, btnWaitIncrease)) { // Button 4 (Wait Time Increase)
    waitTime += 60;  // Each press increases the wait time by 60ms
    delay(200); // Debouncing
  }

  updateLCD(); // Update the LCD display

  // Wait processing
  for (int i = 0; i < waitTime / 60; i++) {
    delay(60);
  }

  // Refresh watchdog timer to prevent reset
  wdt_reset();
}

// Function to update the LCD display
void updateLCD() {
  lcd.setCursor(0, 0); // Display state on the first line
  if (currentState == STOP) {
    lcd.print("STOP       ");
  } else if (currentState == COUNT_UP) {
    lcd.print("COUNT_UP   ");
  } else if (currentState == COUNT_DOWN) {
    lcd.print("COUNT_DOWN ");
  }

  lcd.setCursor(0, 1); // Display time and wait time on the second line
  lcd.print(seconds < 10 ? "0" : ""); // Add leading zero if necessary
  lcd.print(seconds);
  lcd.print(".");
  lcd.print(tenths);
  lcd.print(" s ");
  lcd.print("wait: ");
  lcd.print(waitTime);
  lcd.print(" ms");
}



