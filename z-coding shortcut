https://wokwi.com/projects/409728257464481793

#include <EEPROM.h>
#define NOTE_C4  262
#define NOTE_G3  196
#define NOTE_A3  220
#define NOTE_B3  247

// Pin definitions
const int buttonPin1 = 6;   // Button 1 for toggling play/stop
const int buttonPin2 = 5;   // Button 2 for recording pitch
const int buzzerPin = 13;   // Speaker
const int potPin = A0;      // Potentiometer

// Melody settings (same as the original melody in "Tone Melody" example)
int melody[] = { NOTE_C4, NOTE_G3, NOTE_G3, NOTE_A3, NOTE_G3, 0, NOTE_B3, NOTE_C4 };
int noteDurations[] = {4, 8, 8, 4, 4, 4, 4, 4};
int numNotes = sizeof(melody) / sizeof(melody[0]);

// Playback control variables
bool isPlaying = true;
int lastButton1State = LOW;
int lastButton2State = LOW;
int melodyPosition = 0;  // Keep track of where the melody stopped
int storedPitchAdjust = 0; // Value stored in EEPROM
int pitchAdjust = 0;  // Adjusted pitch based on potentiometer
int potValue;
int button1State;
int button2State;
int adjustedFrequency;
int noteDuration;
int savedPitch;

void setup() {
  pinMode(buttonPin1, INPUT);
  pinMode(buttonPin2, INPUT);
  pinMode(buzzerPin, OUTPUT);
  Serial.begin(9600);

  // Retrieve stored pitch adjust value from EEPROM (Address 0)
  loadPitchFromEEPROM();
}

// Main loop function (treated like main() in structure)
void loop() {
  readButtons();
  adjustPitch();
  if (button1State == HIGH && button2State == HIGH) {
    resetMelody();  // Reset melody if both buttons are pressed simultaneously
  }
  playMelody();
}

// Function to read the button states and handle their logic
void readButtons() {
  button1State = digitalRead(buttonPin1);
  button2State = digitalRead(buttonPin2);

  // Toggle play/stop with button 1
  if (button1State == HIGH && lastButton1State == LOW) {
    isPlaying = !isPlaying;  // Toggle play/stop
    delay(50);               // Debouncing delay
  }
  lastButton1State = button1State;  // Update the last state of button 1

  // Save pitch adjustment to EEPROM with button 2
  if (button2State == HIGH && lastButton2State == LOW) {
    savePitchToEEPROM();  // Store the pitch adjustment
    delay(50);  // Debouncing delay
  }
  lastButton2State = button2State;  // Update the last state of button 2
}

// Function to adjust pitch based on potentiometer value and stored adjustment
void adjustPitch() {
  potValue = analogRead(potPin);
  pitchAdjust = map(potValue, 0, 1023, -100, 100);

  // Calculate total pitch adjustment
  int totalPitchAdjust = storedPitchAdjust + pitchAdjust;
  Serial.print("Total pitch adjust (stored + current): ");
  Serial.println(totalPitchAdjust);
}

// Function to handle the playback of the melody
void playMelody() {
  if (isPlaying) {
    int currentNote = melody[melodyPosition];

    // Apply pitch adjustment if it's not a rest (0 note)
    if (currentNote != 0) {
      int totalPitchAdjust = storedPitchAdjust + pitchAdjust;
      adjustedFrequency = currentNote + totalPitchAdjust;
      noteDuration = 1000 / noteDurations[melodyPosition];
      tone(buzzerPin, adjustedFrequency, noteDuration);
      Serial.print("Playing note: ");
      Serial.println(adjustedFrequency);
    } else {
      Serial.println("Resting (0 note).");
      noTone(buzzerPin);  // Mute during rests
    }

    // Wait for the note to finish playing
    delay(noteDuration * 1.30);
    noTone(buzzerPin);  // Stop the tone after playing

    // Move to the next note
    melodyPosition++;
    if (melodyPosition >= numNotes) {
      melodyPosition = 0;  // Loop back to the start of the melody
    }
  } else {
    noTone(buzzerPin);  // Ensure buzzer is off when stopped
  }
}

// Function to save the current pitch adjustment to EEPROM
void savePitchToEEPROM() {
  int totalPitchAdjust = storedPitchAdjust + pitchAdjust;
  EEPROM.put(0, totalPitchAdjust);  // Store total pitch adjustment
  storedPitchAdjust = totalPitchAdjust;  // Update stored value
  Serial.println("Pitch saved to EEPROM.");
}

// Function to load the pitch adjustment from EEPROM during startup
void loadPitchFromEEPROM() {
  EEPROM.get(0, storedPitchAdjust);  // Retrieve the stored pitch adjustment
  Serial.print("Stored pitch from EEPROM: ");
  Serial.println(storedPitchAdjust);
}

// Function to reset the melody when both buttons are pressed
void resetMelody() {
  isPlaying = false;  // Stop melody playback
  melodyPosition = 0;  // Reset the melody position
}

////////////////
https://wokwi.com/projects/409472516168491009

#include <avr/wdt.h>
#include <LiquidCrystal.h>

// LCD pin configuration (RS, EN, D4, D5, D6, D7)
LiquidCrystal lcd(12, 11, 10, 9, 8, 7);

// Push button pin definitions
const int btnCountUp = 5;   // Push Button 1 for Count Up (PD5)
const int btnCountDown = 4; // Push Button 2 for Count Down (PD4)
const int btnStopReset = 3; // Push Button 3 for Stop/Reset (PD3)
const int btnWaitIncrease = 2; // Push Button 4 for Wait Time Increase (PD2)

// Stopwatch states
enum State {
  STOP,
  COUNT_UP,
  COUNT_DOWN
};

volatile State currentState = STOP;

volatile int seconds = 0;
volatile int tenths = 0;
volatile bool counting = false;
volatile int waitTime = 0; // Wait time in ms, increased by button 4

// Timer1 interrupt service routine (ISR) for 10ms intervals
ISR(TIMER1_COMPA_vect) {
  updateTime(); // Move time update logic to a function
}

void setup() {
  lcd.begin(16, 2); // 16x2 LCD initialization
  lcd.clear();

  // Button input configuration
  configureButtons();

  // Timer1 setup for 10ms interrupts
  setupTimer1();

  // Watchdog Timer setup with 250ms timeout
  wdt_enable(WDTO_250MS);
}

void loop() {
  handleButtons();  // Process button presses
  updateLCD();      // Update the LCD display
  processWaitTime(); // Handle wait processing
  refreshWatchdog(); // Refresh the watchdog timer
}

// Function to handle button presses and logic
void handleButtons() {
  if (isButtonPressed(btnCountUp)) {  // Button 1 (Count Up)
    startCountUp();
  }

  if (isButtonPressed(btnCountDown)) { // Button 2 (Count Down)
    startCountDown();
  }

  if (isButtonPressed(btnStopReset)) { // Button 3 (Stop/Reset)
    stopOrReset();
  }

  if (isButtonPressed(btnWaitIncrease)) { // Button 4 (Wait Time Increase)
    increaseWaitTime();
  }
}

// Function to check if a button is pressed
bool isButtonPressed(int buttonPin) {
  if (bit_is_clear(PIND, buttonPin)) {
    delay(200); // Debouncing delay
    return true;
  }
  return false;
}

// Function to start counting up
void startCountUp() {
  if (!counting && currentState == STOP) {
    currentState = COUNT_UP;
    counting = true;
  }
}

// Function to start counting down
void startCountDown() {
  if (!counting && currentState == STOP) {
    currentState = COUNT_DOWN;
    counting = true;
  }
}

// Function to stop or reset the stopwatch
void stopOrReset() {
  if (counting) {
    counting = false;
    currentState = STOP;
  } else {
    seconds = 0;
    tenths = 0;
  }
}

// Function to increase the wait time by 60ms
void increaseWaitTime() {
  waitTime += 60;
}

// Function to configure button pins
void configureButtons() {
  DDRD &= ~(1 << btnCountUp);
  DDRD &= ~(1 << btnCountDown);
  DDRD &= ~(1 << btnStopReset);
  DDRD &= ~(1 << btnWaitIncrease);

  PORTD |= (1 << btnCountUp);
  PORTD |= (1 << btnCountDown);
  PORTD |= (1 << btnStopReset);
  PORTD |= (1 << btnWaitIncrease);
}

// Function to set up Timer1 for 10ms intervals
void setupTimer1() {
  noInterrupts();
  TCCR1A = 0;
  TCCR1B = 0;
  TCNT1 = 0;
  OCR1A = 1562; // Compare match value for 10ms
  TCCR1B |= (1 << WGM12);  // CTC mode
  TCCR1B |= (1 << CS12) | (1 << CS10);  // Prescaler 1024
  TIMSK1 |= (1 << OCIE1A);  // Enable timer compare interrupt
  interrupts();
}

// Function to handle the updating of time
void updateTime() {
  if (currentState == COUNT_UP) {
    tenths += 1;
    if (tenths >= 10) {
      tenths = 0;
      seconds += 1;
    }
    if (seconds >= 20 && tenths == 0) {
      currentState = STOP;
      counting = false;
    }
  } else if (currentState == COUNT_DOWN) {
    if (tenths == 0 && seconds > 0) {
      tenths = 9;
      seconds -= 1;
    } else if (tenths > 0) {
      tenths -= 1;
    }
    if (seconds == 0 && tenths == 0) {
      currentState = STOP;
      counting = false;
    }
  }
}

// Function to update the LCD display
void updateLCD() {
  lcd.setCursor(0, 0); // Display state on the first line
  if (currentState == STOP) {
    lcd.print("STOP       ");
  } else if (currentState == COUNT_UP) {
    lcd.print("COUNT_UP   ");
  } else if (currentState == COUNT_DOWN) {
    lcd.print("COUNT_DOWN ");
  }

  lcd.setCursor(0, 1); // Display time and wait time on the second line
  lcd.print(seconds < 10 ? "0" : ""); // Add leading zero if necessary
  lcd.print(seconds);
  lcd.print(".");
  lcd.print(tenths);
  lcd.print(" s ");
  lcd.print("wait: ");
  lcd.print(waitTime);
  lcd.print(" ms");
}

// Function to process wait time after increasing it
void processWaitTime() {
  for (int i = 0; i < waitTime / 60; i++) {
    delay(60);
  }
}

// Function to refresh the watchdog timer
void refreshWatchdog() {
  wdt_reset();
}

