#include <EEPROM.h>  // Include EEPROM library for storing values

// Pin definitions
#define BUTTON1_PIN 6   // Play/Stop button connected to digital pin 6 (PD6)
#define BUTTON2_PIN 5   // Record button connected to digital pin 5 (PD5)
#define BUZZER_PIN 13   // Speaker connected to digital pin 13 (PB5)
#define POT_PIN A0      // Potentiometer connected to analog pin A0

// Melody settings
int melody[] = {
  NOTE_C4, NOTE_G3, NOTE_G3, NOTE_A3, NOTE_G3, 0, NOTE_B3, NOTE_C4
};
int noteDurations[] = {4, 8, 8, 4, 4, 4, 4, 4};
int numNotes = sizeof(melody) / sizeof(melody[0]);

// Button and playback state
bool isPlaying = false;  // Tracks whether the melody is playing or not
bool recording = false;  // Tracks if pitch is being recorded
int lastButton1State = LOW; // Last button 1 state for debouncing
int lastButton2State = LOW; // Last button 2 state for debouncing
int currentNoteIndex = 0;   // Track the current note when stopping/starting

// EEPROM memory address for saving pitch
int eepromAddress = 0;

// Variables for pitch control
int savedPitchAdjust = 0;   // Pitch adjustment saved in EEPROM
int pitchAdjust = 0;        // Current pitch adjustment from potentiometer

void setup() {
  Serial.begin(9600); // For debugging purposes

  // Set up buttons as inputs
  DDRD &= ~(1 << BUTTON1_PIN);  // Set button1 pin (PD6) as input
  DDRD &= ~(1 << BUTTON2_PIN);  // Set button2 pin (PD5) as input

  // Set up the buzzer as output
  DDRB |= (1 << PB5);    // Set pin 13 (PB5) as output for the buzzer

  // Retrieve the saved pitch from EEPROM
  savedPitchAdjust = EEPROM.read(eepromAddress);
  if (savedPitchAdjust > 100 || savedPitchAdjust < -100) {
    savedPitchAdjust = 0;  // Initialize to 0 if out of expected range
  }
}

void loop() {
  // Read the potentiometer value and map it to pitch adjustment range (-100Hz to +100Hz)
  int potValue = analogRead(POT_PIN);
  pitchAdjust = map(potValue, 0, 1023, -100, 100);

  // Read the button states
  int button1State = (PIND & (1 << BUTTON1_PIN)) ? HIGH : LOW;  // Read button1 state (PD6)
  int button2State = (PIND & (1 << BUTTON2_PIN)) ? HIGH : LOW;  // Read button2 state (PD5)

  // Button 1: Toggle play/stop
  if (button1State == HIGH && lastButton1State == LOW) {
    isPlaying = !isPlaying;  // Toggle between play and stop
    delay(50);               // Debouncing delay
  }
  lastButton1State = button1State;

  // Button 2: Record pitch to EEPROM
  if (button2State == HIGH && lastButton2State == LOW) {
    recording = true;  // Mark that pitch is being recorded
    savedPitchAdjust = pitchAdjust;
    EEPROM.write(eepromAddress, savedPitchAdjust);  // Save to EEPROM
    delay(50);  // Debouncing delay
  }
  lastButton2State = button2State;

  // Simultaneous button press: Stop melody and reset playback position
  if (button1State == HIGH && button2State == HIGH) {
    isPlaying = false;   // Stop the melody
    currentNoteIndex = 0;  // Reset the playback position
  }

  // Melody playback logic
  if (isPlaying) {
    // Play the current note with adjusted pitch
    int adjustedFrequency = melody[currentNoteIndex] + savedPitchAdjust + pitchAdjust;
    int noteDuration = 1000 / noteDurations[currentNoteIndex];
    
    // Generate tone using direct port manipulation for buzzer pin
    toneOn(adjustedFrequency);  // Turn the buzzer on with adjusted frequency
    delay(noteDuration * 1.30); // Wait for the note to finish

    // Move to the next note
    currentNoteIndex++;
    if (currentNoteIndex >= numNotes) {
      currentNoteIndex = 0;  // Loop back to the start of the melody
    }
  } else {
    noTone();  // Stop the buzzer when the melody is stopped
  }
}

// Helper function to generate a tone using direct register manipulation
void toneOn(int frequency) {
  // Generate square wave using PORTB for the buzzer
  int halfPeriod = 1000000L / frequency / 2;
  for (int i = 0; i < (frequency * 2); i++) {
    PORTB |= (1 << PB5);  // Set pin 13 high
    delayMicroseconds(halfPeriod);
    PORTB &= ~(1 << PB5); // Set pin 13 low
    delayMicroseconds(halfPeriod);
  }
}

// Helper function to stop the buzzer using direct register manipulation
void noTone() {
  PORTB &= ~(1 << PB5);  // Set pin 13 low to stop the buzzer
}