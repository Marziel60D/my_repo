////////88888888////////
#include <LiquidCrystal.h>

// LCD pin configuration (RS, EN, D4, D5, D6, D7)
LiquidCrystal lcd(12, 11, 10, 9, 8, 7);

// Push button pin definitions
const int btnCountUp = 5;   // Push Button 1 for Count Up
const int btnCountDown = 4; // Push Button 2 for Count Down
const int btnStopReset = 3; // Push Button 3 for Stop/Reset
const int btnNext = 2;      // Push Button 4 for Next Exercise

// Stopwatch states
enum State {
  STOP,
  COUNT_UP,
  COUNT_DOWN
};

volatile State currentState = STOP;
volatile float count = 0.0;
volatile bool counting = false;

// Timer1 interrupt service routine (ISR)
ISR(TIMER1_COMPA_vect) {
  // Increment or decrement the count based on current state
  if (currentState == COUNT_UP) {
    count += 0.1;
    if (count >= 20.0) {
      count = 20.0;
      currentState = STOP;
      counting = false;
    }
  } else if (currentState == COUNT_DOWN) {
    count -= 0.1;
    if (count <= 0.0) {
      count = 0.0;
      currentState = STOP;
      counting = false;
    }
  }
}

// Setup function for Timer1 and other components
void setup() {
  // LCD initialization
  lcd.begin(16, 2);
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("Status: STOP");
  lcd.setCursor(0, 1);
  lcd.print("Count: 0.0 s");

  // Timer1 initialization for 100ms intervals (0.1 seconds)
  noInterrupts();           // Disable all interrupts
  TCCR1A = 0;               // Reset TCCR1A register
  TCCR1B = 0;               // Reset TCCR1B register
  TCNT1 = 0;                // Reset the counter
  OCR1A = 15624;            // Compare match value for 100ms (16MHz / 1024 / 10Hz)
  TCCR1B |= (1 << WGM12);   // Set CTC mode
  TCCR1B |= (1 << CS12) | (1 << CS10); // Set prescaler to 1024
  TIMSK1 |= (1 << OCIE1A);  // Enable Timer1 compare match A interrupt
  interrupts();             // Enable all interrupts
}

// Function to handle the state transitions and button presses
void loop() {
  // Polling buttons and handling state transitions
  if (bit_is_clear(PIND, btnCountUp)) {  // Button 1 (Count Up)
    if (!counting && currentState == STOP) {
      currentState = COUNT_UP;
      counting = true;
    }
    delay(200);  // Debouncing
  }

  if (bit_is_clear(PIND, btnCountDown)) {  // Button 2 (Count Down)
    if (!counting && currentState == STOP) {
      currentState = COUNT_DOWN;
      counting = true;
    }
    delay(200);  // Debouncing
  }

  if (bit_is_clear(PIND, btnStopReset)) {  // Button 3 (Stop/Reset)
    if (counting) {
      counting = false;
      currentState = STOP;
    } else {
      count = 0.0;
    }
    delay(200);  // Debouncing
  }

  // Update the LCD based on current state and count
  updateLCD();
}

// Function to update the LCD display
void updateLCD() {
  lcd.clear();
  
  // Display current state on the first line
  lcd.setCursor(0, 0);
  if (currentState == STOP) {
    lcd.print("Status: STOP");
  } else if (currentState == COUNT_UP) {
    lcd.print("Status: COUNT_UP");
  } else if (currentState == COUNT_DOWN) {
    lcd.print("Status: COUNT_DOWN");
  }

  // Display the count value on the second line
  lcd.setCursor(0, 1);
  lcd.print("Count: ");
  lcd.print(count, 1);  // Print the count value with 1 decimal place
  lcd.print(" s");
}




Hereâ€™s an implementation of the stopwatch system using Timer Interrupts in Arduino UNO, involving state transitions for counting up, counting down, and stopping, with an LCD displaying the current state and count value. The code adheres to the restriction of not using pinMode, digitalRead, digitalWrite, millis(), or micros(). We will use Timer1 interrupts to handle timing.

Arduino Code

#include <LiquidCrystal.h>

// LCD pin configuration (RS, EN, D4, D5, D6, D7)
LiquidCrystal lcd(12, 11, 10, 9, 8, 7);

// Push button pin definitions
const int btnCountUp = 5;   // Push Button 1 for Count Up
const int btnCountDown = 4; // Push Button 2 for Count Down
const int btnStopReset = 3; // Push Button 3 for Stop/Reset
const int btnNext = 2;      // Push Button 4 for Next Exercise

// Stopwatch states
enum State {
  STOP,
  COUNT_UP,
  COUNT_DOWN
};

volatile State currentState = STOP;
volatile float count = 0.0;
volatile bool counting = false;

// Timer1 interrupt service routine (ISR)
ISR(TIMER1_COMPA_vect) {
  // Increment or decrement the count based on current state
  if (currentState == COUNT_UP) {
    count += 0.1;
    if (count >= 20.0) {
      count = 20.0;
      currentState = STOP;
      counting = false;
    }
  } else if (currentState == COUNT_DOWN) {
    count -= 0.1;
    if (count <= 0.0) {
      count = 0.0;
      currentState = STOP;
      counting = false;
    }
  }
}

// Setup function for Timer1 and other components
void setup() {
  // LCD initialization
  lcd.begin(16, 2);
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("Status: STOP");
  lcd.setCursor(0, 1);
  lcd.print("Count: 0.0 s");

  // Timer1 initialization for 100ms intervals (0.1 seconds)
  noInterrupts();           // Disable all interrupts
  TCCR1A = 0;               // Reset TCCR1A register
  TCCR1B = 0;               // Reset TCCR1B register
  TCNT1 = 0;                // Reset the counter
  OCR1A = 15624;            // Compare match value for 100ms (16MHz / 1024 / 10Hz)
  TCCR1B |= (1 << WGM12);   // Set CTC mode
  TCCR1B |= (1 << CS12) | (1 << CS10); // Set prescaler to 1024
  TIMSK1 |= (1 << OCIE1A);  // Enable Timer1 compare match A interrupt
  interrupts();             // Enable all interrupts
}

// Function to handle the state transitions and button presses
void loop() {
  // Polling buttons and handling state transitions
  if (bit_is_clear(PIND, btnCountUp)) {  // Button 1 (Count Up)
    if (!counting && currentState == STOP) {
      currentState = COUNT_UP;
      counting = true;
    }
    delay(200);  // Debouncing
  }

  if (bit_is_clear(PIND, btnCountDown)) {  // Button 2 (Count Down)
    if (!counting && currentState == STOP) {
      currentState = COUNT_DOWN;
      counting = true;
    }
    delay(200);  // Debouncing
  }

  if (bit_is_clear(PIND, btnStopReset)) {  // Button 3 (Stop/Reset)
    if (counting) {
      counting = false;
      currentState = STOP;
    } else {
      count = 0.0;
    }
    delay(200);  // Debouncing
  }

  // Update the LCD based on current state and count
  updateLCD();
}

// Function to update the LCD display
void updateLCD() {
  lcd.clear();
  
  // Display current state on the first line
  lcd.setCursor(0, 0);
  if (currentState == STOP) {
    lcd.print("Status: STOP");
  } else if (currentState == COUNT_UP) {
    lcd.print("Status: COUNT_UP");
  } else if (currentState == COUNT_DOWN) {
    lcd.print("Status: COUNT_DOWN");
  }

  // Display the count value on the second line
  lcd.setCursor(0, 1);
  lcd.print("Count: ");
  lcd.print(count, 1);  // Print the count value with 1 decimal place
  lcd.print(" s");
}

Code Explanation

1. LCD Initialization:
The LiquidCrystal library is used to control the LCD. The lcd.begin(16, 2) initializes a 16x2 LCD, and we define the pin connections between the Arduino and LCD.


2. Button Handling:
Four buttons are used for controlling the stopwatch's behavior. Button states are read using bit_is_clear() from PIND to detect when a button is pressed. Buttons perform specific actions:

Button 1 (Count Up): Starts counting up from 0 to 20 seconds.

Button 2 (Count Down): Starts counting down from the current count to 0.

Button 3 (Stop/Reset): Stops the counting or resets the count when stopped.

Button 4: Reserved for future use.



3. Timer1 Setup:
Timer1 is configured to generate an interrupt every 100ms. The ISR(TIMER1_COMPA_vect) function is triggered on each interrupt, handling the increment or decrement of the count value based on the current state (COUNT_UP or COUNT_DOWN).


4. LCD Update:
The updateLCD() function updates the LCD display, showing the current state (STOP, COUNT_UP, or COUNT_DOWN) and the count value in seconds with one decimal place.



Required Circuit Connections

Buttons:

Button 1 to Pin 5

Button 2 to Pin 4

Button 3 to Pin 3

Button 4 to Pin 2


LCD:

RS: Pin 12

Enable: Pin 11

D4, D5, D6, D7: Pins 10, 9, 8, 7



Timer Settings

Timer1: Configured for 100ms intervals (0.1 seconds). The prescaler is set to 1024, and the compare match value (OCR1A) is calculated as:


OCR1A = \frac{16MHz}{1024 \times 10Hz} - 1 = 15624

Restrictions Considerations

No pinMode: Button states are directly read using bit_is_clear() on PIND registers.

No digitalRead/digitalWrite: Buttons and the LCD are controlled via direct manipulation of hardware registers.

No millis() or micros(): Timing is handled by the Timer1 interrupt.







////////////999999999///////
#include <EEPROM.h>  // Include EEPROM library for saving pitch

// Pin definitions
const int buttonPin1 = 6;   // Button 1 for toggling play/stop
const int buttonPin2 = 5;   // Button 2 for recording pitch
const int buzzerPin = 13;   // Speaker
const int potPin = A0;      // Potentiometer

// Melody settings (same as the original melody in "Tone Melody" example)
int melody[] = {
  NOTE_C4, NOTE_G3, NOTE_G3, NOTE_A3, NOTE_G3, 0, NOTE_B3, NOTE_C4
};
int noteDurations[] = {4, 8, 8, 4, 4, 4, 4, 4};
int numNotes = sizeof(melody) / sizeof(melody[0]);

// Playback control variables
bool isPlaying = false;
int lastButton1State = LOW;
int lastButton2State = LOW;
int melodyPosition = 0;  // Keep track of where the melody stopped
int storedPitchAdjust = 0; // Value stored in EEPROM
int pitchAdjust = 0;  // Adjusted pitch based on potentiometer

void setup() {
  pinMode(buttonPin1, INPUT);
  pinMode(buttonPin2, INPUT);
  pinMode(buzzerPin, OUTPUT);
  Serial.begin(9600);

  // Retrieve stored pitch adjust value from EEPROM (Address 0)
  storedPitchAdjust = EEPROM.read(0);

  // Print stored pitch on startup
  Serial.print("Stored Pitch from EEPROM: ");
  Serial.println(storedPitchAdjust);
}

void loop() {
  // Read potentiometer value and map it to pitch adjustment range (-100Hz to +100Hz)
  int potValue = analogRead(potPin);
  pitchAdjust = map(potValue, 0, 1023, -100, 100);

  // Read button states
  int button1State = digitalRead(buttonPin1);
  int button2State = digitalRead(buttonPin2);

  // Handle button 1 for toggling play/stop
  if (button1State == HIGH && lastButton1State == LOW) {
    isPlaying = !isPlaying;  // Toggle between play and stop
    delay(50);               // Debouncing delay
  }
  lastButton1State = button1State;  // Update the last state of button 1

  // Handle button 2 for recording pitch
  if (button2State == HIGH && lastButton2State == LOW) {
    EEPROM.write(0, pitchAdjust);  // Store the current pitch adjustment value in EEPROM
    storedPitchAdjust = pitchAdjust;  // Update the stored pitch
    Serial.print("Pitch saved to EEPROM: ");
    Serial.println(storedPitchAdjust);
    delay(50);  // Debouncing delay
  }
  lastButton2State = button2State;  // Update the last state of button 2

  // Handle simultaneous button press (both button 1 and 2)
  if (button1State == HIGH && button2State == HIGH) {
    isPlaying = false;  // Stop melody playback
    melodyPosition = 0;  // Reset melody position to start
  }

  // Play melody if it's toggled to play mode
  if (isPlaying) {
    // Print the current pitch being applied
    Serial.print("Stored Pitch: ");
    Serial.print(storedPitchAdjust);
    Serial.print(", Current Pitch Adjust (Potentiometer): ");
    Serial.println(pitchAdjust);

    int adjustedFrequency = melody[melodyPosition] + storedPitchAdjust + pitchAdjust; // Apply stored and current pitch adjustment

    // Calculate note duration
    int noteDuration = 1000 / noteDurations[melodyPosition];
    tone(buzzerPin, adjustedFrequency, noteDuration);

    // Wait for the note to finish playing
    delay(noteDuration * 1.30);
    noTone(buzzerPin);  // Stop the tone

    // Move to the next note
    melodyPosition++;
    if (melodyPosition >= numNotes) {
      melodyPosition = 0;  // Loop back to the start of the melody
    }
  } else {
    noTone(buzzerPin);  // Ensure buzzer is off when stopped
  }
}


////////////

#include <EEPROM.h>

const int buttonPin1 = 6;            // Push button 1 for toggling play/stop
const int buttonPin2 = 5;            // Push button 2 for recording pitch
const int buzzerPin = 13;            // Speaker
const int potPin = A0;               // Potentiometer
const int EEPROMAddress = 0;         // EEPROM address for storing pitch

int melody[] = {
  NOTE_C4, NOTE_G3, NOTE_G3, NOTE_A3, NOTE_G3, 0, NOTE_B3, NOTE_C4
};

int noteDurations[] = {
  4, 8, 8, 4, 4, 4, 4, 4
};

bool isPlaying = false;              // To track if melody is playing
int lastButtonState1 = LOW;          // Last state of button 1 for debouncing
int lastButtonState2 = LOW;          // Last state of button 2 for debouncing
int melodyPosition = 0;              // Current melody position
int storedPitch = 0;                 // Stored pitch in EEPROM
int currentPitch = 0;                // Current pitch

void setup() {
  pinMode(buttonPin1, INPUT);
  pinMode(buttonPin2, INPUT);
  pinMode(buzzerPin, OUTPUT);
  Serial.begin(9600);                // Initialize serial for debugging

  storedPitch = EEPROM.read(EEPROMAddress);  // Read stored pitch from EEPROM
  Serial.print("Stored Pitch: ");
  Serial.println(storedPitch);        // Print stored pitch
}

void loop() {
  int potValue = analogRead(potPin);  // Read potentiometer value
  int pitchAdjust = map(potValue, 0, 1023, -100, 100);  // Map potentiometer value

  currentPitch = storedPitch + pitchAdjust;  // Adjust the current pitch
  Serial.print("Current Pitch: ");
  Serial.println(currentPitch);        // Print current pitch

  int buttonState1 = digitalRead(buttonPin1);  // Read button 1 state
  int buttonState2 = digitalRead(buttonPin2);  // Read button 2 state

  if (buttonState1 == HIGH && lastButtonState1 == LOW) { // Toggle play/stop
    isPlaying = !isPlaying;
    delay(50);  // Debounce delay
  }
  lastButtonState1 = buttonState1;

  if (buttonState2 == HIGH && lastButtonState2 == LOW) { // Record pitch to EEPROM
    EEPROM.write(EEPROMAddress, currentPitch);
    storedPitch = currentPitch;  // Update stored pitch
    delay(50);  // Debounce delay
  }
  lastButtonState2 = buttonState2;

  if (buttonState1 == HIGH && buttonState2 == HIGH) {  // Reset melody to start
    isPlaying = false;
    melodyPosition = 0;
  }

  if (isPlaying) {  // Play melody if isPlaying is true
    for (int thisNote = melodyPosition; thisNote < 8; thisNote++) {
      int noteDuration = 1000 / noteDurations[thisNote];
      tone(buzzerPin, melody[thisNote] + currentPitch, noteDuration);

      int pauseBetweenNotes = noteDuration * 1.30;
      delay(pauseBetweenNotes);
      noTone(buzzerPin);

      int buttonState1 = digitalRead(buttonPin1);
      if (buttonState1 == HIGH && lastButtonState1 == LOW) {
        isPlaying = false;
        melodyPosition = thisNote;  // Save position to resume later
        break;
      }
      lastButtonState1 = buttonState1;
    }
  } else {
    noTone(buzzerPin);
  }
}
